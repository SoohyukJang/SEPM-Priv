{"ast":null,"code":"import { getFirestore, doc, getDoc, setDoc, updateDoc, arrayUnion, arrayRemove } from 'firebase/firestore';\nimport { app } from '../firebase/config';\nconst API_KEY = 'eeb775beabdd459eb5f8e5983978fff1';\nconst BASE_URL = 'https://api.spoonacular.com/recipes';\nconst db = getFirestore(app);\n\n// Sample data to use when API calls fail\nconst sampleRecipes = [{\n  id: 715538,\n  title: \"What to make for dinner tonight?? Bruschetta Style Pork & Pasta\",\n  image: \"https://img.spoonacular.com/recipes/715538-312x231.jpg\",\n  readyInMinutes: 45,\n  servings: 2,\n  vegetarian: true,\n  vegan: false,\n  glutenFree: false,\n  dairyFree: false\n}, {\n  id: 716429,\n  title: \"Simple Skillet Lasagna\",\n  image: \"https://spoonacular.com/recipeImages/716429-312x231.jpg\",\n  readyInMinutes: 35,\n  servings: 4,\n  vegetarian: false,\n  vegan: false,\n  glutenFree: false,\n  dairyFree: false\n}, {\n  id: 715497,\n  title: \"Berry Banana Breakfast Smoothie\",\n  image: \"https://spoonacular.com/recipeImages/715497-312x231.jpg\",\n  readyInMinutes: 5,\n  servings: 1,\n  vegetarian: true,\n  vegan: true,\n  glutenFree: true,\n  dairyFree: true\n}, {\n  id: 721146,\n  title: \"Homemade Strawberry Lemonade\",\n  image: \"https://spoonacular.com/recipeImages/721146-312x231.jpg\",\n  readyInMinutes: 15,\n  servings: 8,\n  vegetarian: true,\n  vegan: true,\n  glutenFree: true,\n  dairyFree: true\n}\n// More sample recipes...\n];\n\n// Cache for storing API responses\nconst apiCache = {\n  searches: {},\n  recipes: {},\n  recommendations: {}\n};\n\n// Check if we have network connection\nconst isOnline = () => {\n  return navigator.onLine;\n};\n\n// Helper to construct API URLs with params\nconst buildApiUrl = (endpoint, params = {}) => {\n  const url = new URL(`${BASE_URL}/${endpoint}`);\n  url.searchParams.append('apiKey', API_KEY);\n  Object.entries(params).forEach(([key, value]) => {\n    if (value !== undefined && value !== null && value !== '') {\n      url.searchParams.append(key, value);\n    }\n  });\n  return url.toString();\n};\n\n// Filter sample recipes based on user filters\nconst filterSampleRecipes = filters => {\n  let filtered = [...sampleRecipes];\n  if (filters.query) {\n    const query = filters.query.toLowerCase();\n    filtered = filtered.filter(recipe => recipe.title.toLowerCase().includes(query));\n  }\n  if (filters.diet === 'vegetarian') {\n    filtered = filtered.filter(recipe => recipe.vegetarian);\n  } else if (filters.diet === 'vegan') {\n    filtered = filtered.filter(recipe => recipe.vegan);\n  } else if (filters.diet === 'gluten free') {\n    filtered = filtered.filter(recipe => recipe.glutenFree);\n  } else if (filters.diet === 'dairy free') {\n    filtered = filtered.filter(recipe => recipe.dairyFree);\n  }\n  if (filters.maxReadyTime) {\n    filtered = filtered.filter(recipe => recipe.readyInMinutes <= filters.maxReadyTime);\n  }\n  return filtered;\n};\n\n// Helper to create cache key from filters\nconst createCacheKey = filters => {\n  return JSON.stringify(filters);\n};\nexport const fetchRecipes = async filters => {\n  try {\n    const cacheKey = createCacheKey(filters);\n\n    // Check cache first\n    if (apiCache.searches[cacheKey]) {\n      console.log(\"Using cached search results\");\n      return apiCache.searches[cacheKey];\n    }\n\n    // If offline, use sample data\n    if (!isOnline()) {\n      console.log(\"Offline mode: Using sample data\");\n      return filterSampleRecipes(filters);\n    }\n    const {\n      query,\n      cuisine,\n      diet,\n      intolerances,\n      maxReadyTime,\n      sort,\n      offset,\n      number = 10\n    } = filters;\n\n    // Build API params\n    const params = {\n      query,\n      cuisine,\n      diet,\n      intolerances,\n      maxReadyTime,\n      sort,\n      offset,\n      number,\n      addRecipeInformation: true,\n      fillIngredients: true\n    };\n\n    // Add additional filters if provided\n    if (filters.includeIngredients) params.includeIngredients = filters.includeIngredients;\n    if (filters.excludeIngredients) params.excludeIngredients = filters.excludeIngredients;\n    if (filters.type) params.type = filters.type;\n    if (filters.minCalories) params.minCalories = filters.minCalories;\n    if (filters.maxCalories) params.maxCalories = filters.maxCalories;\n    if (filters.minProtein) params.minProtein = filters.minProtein;\n    if (filters.maxProtein) params.maxProtein = filters.maxProtein;\n    if (filters.minCarbs) params.minCarbs = filters.minCarbs;\n    if (filters.maxCarbs) params.maxCarbs = filters.maxCarbs;\n    if (filters.minFat) params.minFat = filters.minFat;\n    if (filters.maxFat) params.maxFat = filters.maxFat;\n    const url = buildApiUrl('complexSearch', params);\n    console.log(\"Fetching recipes from API:\", url);\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(\"API request failed with status: \" + response.status);\n    }\n    const data = await response.json();\n    const results = data.results || [];\n\n    // Cache the results\n    apiCache.searches[cacheKey] = results;\n    return results;\n  } catch (error) {\n    console.error(\"Error in fetchRecipes:\", error);\n    // Fallback to sample data\n    return filterSampleRecipes(filters);\n  }\n};\nexport const searchRecipes = fetchRecipes;\nexport const fetchRecipeById = async recipeId => {\n  try {\n    // Check cache first\n    if (apiCache.recipes[recipeId]) {\n      console.log(`Using cached recipe data for ID: ${recipeId}`);\n      return apiCache.recipes[recipeId];\n    }\n\n    // If offline, use sample data\n    if (!isOnline()) {\n      console.log(\"Offline mode: Using sample data for recipe details\");\n      const recipe = sampleRecipes.find(r => r.id === parseInt(recipeId));\n      if (recipe) return recipe;\n      throw new Error(\"Recipe not found in sample data\");\n    }\n\n    // Fetch from API\n    const params = {\n      includeNutrition: true\n    };\n    const url = buildApiUrl(`${recipeId}/information`, params);\n    console.log(`Fetching recipe details for ID: ${recipeId}`);\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(\"API request failed with status: \" + response.status);\n    }\n    const recipe = await response.json();\n\n    // Cache the recipe\n    apiCache.recipes[recipeId] = recipe;\n    return recipe;\n  } catch (error) {\n    console.error(`Error fetching recipe ${recipeId}:`, error);\n\n    // Try to find in sample data as fallback\n    const recipe = sampleRecipes.find(r => r.id === parseInt(recipeId));\n    if (recipe) {\n      return recipe;\n    }\n    throw error;\n  }\n};\nexport const getRecipeById = fetchRecipeById;\nexport const getSimilarRecipes = async recipeId => {\n  try {\n    // If offline, use sample data\n    if (!isOnline()) {\n      console.log(\"Offline mode: Using sample data for similar recipes\");\n      const shuffled = [...sampleRecipes].sort(() => 0.5 - Math.random());\n      return shuffled.slice(0, 4);\n    }\n    const url = buildApiUrl(`${recipeId}/similar`, {\n      number: 4\n    });\n    console.log(`Fetching similar recipes for ID: ${recipeId}`);\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(\"API request failed with status: \" + response.status);\n    }\n    const similarRecipes = await response.json();\n\n    // Fetch full details for each similar recipe\n    const detailedRecipes = await Promise.all(similarRecipes.map(async recipe => {\n      try {\n        return await fetchRecipeById(recipe.id);\n      } catch (error) {\n        console.error(`Error fetching details for similar recipe ${recipe.id}:`, error);\n        return recipe; // Return basic info if details fetch fails\n      }\n    }));\n    return detailedRecipes;\n  } catch (error) {\n    console.error(\"Error in getSimilarRecipes:\", error);\n    // Fallback to sample data\n    const shuffled = [...sampleRecipes].sort(() => 0.5 - Math.random());\n    return shuffled.slice(0, 4);\n  }\n};\nexport const getRecommendations = async userProfile => {\n  try {\n    // Create a unique cache key based on user profile\n    const cacheKey = userProfile ? JSON.stringify(userProfile) : 'default';\n\n    // Check cache first\n    if (apiCache.recommendations[cacheKey]) {\n      console.log(\"Using cached recommendations\");\n      return apiCache.recommendations[cacheKey];\n    }\n\n    // If offline, use sample data\n    if (!isOnline()) {\n      console.log(\"Offline mode: Using sample data for recommendations\");\n      return filterSampleRecipes({});\n    }\n\n    // Default parameters if user profile is not available\n    let diet = '';\n    let intolerances = [];\n    let query = '';\n    let maxCalories = null;\n    let minProtein = null;\n\n    // If user profile exists, use it to customize recommendations\n    if (userProfile) {\n      if (userProfile.goal === 'Weight Loss') {\n        diet = 'low-calorie';\n        maxCalories = Math.round(userProfile.tdee * 0.8); // 20% deficit\n      } else if (userProfile.goal === 'Build Muscle') {\n        diet = 'high-protein';\n        minProtein = 25; // Minimum 25g protein per serving\n      } else if (userProfile.goal === 'Maintain Weight') {\n        // Use TDEE as calories target\n      }\n      intolerances = userProfile.allergies || [];\n    }\n\n    // Create filters object for fetching recipes\n    const filters = {\n      query,\n      diet,\n      intolerances: intolerances.join(','),\n      sort: 'popularity',\n      maxReadyTime: 60,\n      number: 10,\n      maxCalories,\n      minProtein,\n      addRecipeInformation: true\n    };\n    const results = await fetchRecipes(filters);\n\n    // Cache the recommendations\n    apiCache.recommendations[cacheKey] = results;\n    return results;\n  } catch (error) {\n    console.error('Error getting recommendations:', error);\n    return filterSampleRecipes({});\n  }\n};\nexport const saveRecipe = async (userId, recipe) => {\n  try {\n    const userRef = doc(db, 'users', userId);\n    const userDoc = await getDoc(userRef);\n    if (!userDoc.exists()) {\n      // Create user document if it doesn't exist\n      await setDoc(userRef, {\n        savedRecipes: [recipe]\n      });\n    } else {\n      // Add recipe to existing savedRecipes array\n      await updateDoc(userRef, {\n        savedRecipes: arrayUnion(recipe)\n      });\n    }\n    return true;\n  } catch (error) {\n    console.error('Error saving recipe:', error);\n    throw error;\n  }\n};\nexport const removeRecipe = async (userId, recipeId) => {\n  try {\n    const userRef = doc(db, 'users', userId);\n    const userDoc = await getDoc(userRef);\n    if (userDoc.exists()) {\n      const savedRecipes = userDoc.data().savedRecipes || [];\n      const recipeToRemove = savedRecipes.find(recipe => recipe.id === recipeId);\n      if (recipeToRemove) {\n        await updateDoc(userRef, {\n          savedRecipes: arrayRemove(recipeToRemove)\n        });\n      }\n    }\n    return true;\n  } catch (error) {\n    console.error('Error removing recipe:', error);\n    throw error;\n  }\n};\nexport const getSavedRecipes = async userId => {\n  try {\n    const userRef = doc(db, 'users', userId);\n    const userDoc = await getDoc(userRef);\n    if (userDoc.exists()) {\n      return userDoc.data().savedRecipes || [];\n    }\n    return [];\n  } catch (error) {\n    console.error('Error getting saved recipes:', error);\n    throw error;\n  }\n};\n\n// Clear cache\nexport const clearCache = () => {\n  apiCache.searches = {};\n  apiCache.recipes = {};\n  apiCache.recommendations = {};\n  console.log(\"API cache cleared\");\n};\n\n// New function to check if a recipe is saved by user\nexport const isRecipeSaved = async (userId, recipeId) => {\n  try {\n    if (!userId) return false;\n    const savedRecipes = await getSavedRecipes(userId);\n    return savedRecipes.some(recipe => recipe.id === parseInt(recipeId));\n  } catch (error) {\n    console.error('Error checking if recipe is saved:', error);\n    return false;\n  }\n};\n\n// New function for advanced recipe search\nexport const advancedRecipeSearch = async filters => {\n  return fetchRecipes({\n    ...filters,\n    addRecipeInformation: true,\n    fillIngredients: true\n  });\n};\n\n// New function to search by ingredients\nexport const searchByIngredients = async (ingredients, number = 10) => {\n  try {\n    if (!isOnline()) {\n      console.log(\"Offline mode: Using sample data for ingredients search\");\n      return filterSampleRecipes({});\n    }\n    const params = {\n      ingredients: ingredients.join(','),\n      number,\n      ranking: 1,\n      // Maximize used ingredients\n      ignorePantry: true\n    };\n    const url = buildApiUrl('findByIngredients', params);\n    console.log(\"Searching recipes by ingredients:\", url);\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(\"API request failed with status: \" + response.status);\n    }\n    const results = await response.json();\n\n    // Get full recipe details for each result\n    const detailedRecipes = await Promise.all(results.map(async recipe => {\n      try {\n        return await fetchRecipeById(recipe.id);\n      } catch (error) {\n        console.error(`Error fetching details for recipe ${recipe.id}:`, error);\n        return recipe; // Return basic info if details fetch fails\n      }\n    }));\n    return detailedRecipes;\n  } catch (error) {\n    console.error(\"Error in searchByIngredients:\", error);\n    return filterSampleRecipes({});\n  }\n};","map":{"version":3,"names":["getFirestore","doc","getDoc","setDoc","updateDoc","arrayUnion","arrayRemove","app","API_KEY","BASE_URL","db","sampleRecipes","id","title","image","readyInMinutes","servings","vegetarian","vegan","glutenFree","dairyFree","apiCache","searches","recipes","recommendations","isOnline","navigator","onLine","buildApiUrl","endpoint","params","url","URL","searchParams","append","Object","entries","forEach","key","value","undefined","toString","filterSampleRecipes","filters","filtered","query","toLowerCase","filter","recipe","includes","diet","maxReadyTime","createCacheKey","JSON","stringify","fetchRecipes","cacheKey","console","log","cuisine","intolerances","sort","offset","number","addRecipeInformation","fillIngredients","includeIngredients","excludeIngredients","type","minCalories","maxCalories","minProtein","maxProtein","minCarbs","maxCarbs","minFat","maxFat","response","fetch","ok","Error","status","data","json","results","error","searchRecipes","fetchRecipeById","recipeId","find","r","parseInt","includeNutrition","getRecipeById","getSimilarRecipes","shuffled","Math","random","slice","similarRecipes","detailedRecipes","Promise","all","map","getRecommendations","userProfile","goal","round","tdee","allergies","join","saveRecipe","userId","userRef","userDoc","exists","savedRecipes","removeRecipe","recipeToRemove","getSavedRecipes","clearCache","isRecipeSaved","some","advancedRecipeSearch","searchByIngredients","ingredients","ranking","ignorePantry"],"sources":["C:/Users/SoohyukJANG/Documents/GitHub/SEPM-Priv/SEPM/src/services/apiService.js"],"sourcesContent":["import { getFirestore, doc, getDoc, setDoc, updateDoc, arrayUnion, arrayRemove} from 'firebase/firestore';\r\nimport { app } from '../firebase/config';\r\n\r\nconst API_KEY = 'eeb775beabdd459eb5f8e5983978fff1';\r\nconst BASE_URL = 'https://api.spoonacular.com/recipes';\r\nconst db = getFirestore(app);\r\n\r\n// Sample data to use when API calls fail\r\nconst sampleRecipes = [\r\n  {\r\n    id: 715538,\r\n    title: \"What to make for dinner tonight?? Bruschetta Style Pork & Pasta\",\r\n    image: \"https://img.spoonacular.com/recipes/715538-312x231.jpg\",\r\n    readyInMinutes: 45,\r\n    servings: 2,\r\n    vegetarian: true,\r\n    vegan: false,\r\n    glutenFree: false,\r\n    dairyFree: false\r\n  },\r\n  {\r\n    id: 716429,\r\n    title: \"Simple Skillet Lasagna\",\r\n    image: \"https://spoonacular.com/recipeImages/716429-312x231.jpg\",\r\n    readyInMinutes: 35,\r\n    servings: 4,\r\n    vegetarian: false,\r\n    vegan: false,\r\n    glutenFree: false,\r\n    dairyFree: false\r\n  },\r\n  {\r\n    id: 715497,\r\n    title: \"Berry Banana Breakfast Smoothie\",\r\n    image: \"https://spoonacular.com/recipeImages/715497-312x231.jpg\",\r\n    readyInMinutes: 5,\r\n    servings: 1,\r\n    vegetarian: true,\r\n    vegan: true,\r\n    glutenFree: true,\r\n    dairyFree: true\r\n  },\r\n  {\r\n    id: 721146,\r\n    title: \"Homemade Strawberry Lemonade\",\r\n    image: \"https://spoonacular.com/recipeImages/721146-312x231.jpg\",\r\n    readyInMinutes: 15,\r\n    servings: 8,\r\n    vegetarian: true,\r\n    vegan: true,\r\n    glutenFree: true,\r\n    dairyFree: true\r\n  },\r\n  // More sample recipes...\r\n];\r\n\r\n// Cache for storing API responses\r\nconst apiCache = {\r\n  searches: {},\r\n  recipes: {},\r\n  recommendations: {}\r\n};\r\n\r\n// Check if we have network connection\r\nconst isOnline = () => {\r\n  return navigator.onLine;\r\n};\r\n\r\n// Helper to construct API URLs with params\r\nconst buildApiUrl = (endpoint, params = {}) => {\r\n  const url = new URL(`${BASE_URL}/${endpoint}`);\r\n  url.searchParams.append('apiKey', API_KEY);\r\n  \r\n  Object.entries(params).forEach(([key, value]) => {\r\n    if (value !== undefined && value !== null && value !== '') {\r\n      url.searchParams.append(key, value);\r\n    }\r\n  });\r\n  \r\n  return url.toString();\r\n};\r\n\r\n// Filter sample recipes based on user filters\r\nconst filterSampleRecipes = (filters) => {\r\n  let filtered = [...sampleRecipes];\r\n  \r\n  if (filters.query) {\r\n    const query = filters.query.toLowerCase();\r\n    filtered = filtered.filter(recipe => \r\n      recipe.title.toLowerCase().includes(query)\r\n    );\r\n  }\r\n  \r\n  if (filters.diet === 'vegetarian') {\r\n    filtered = filtered.filter(recipe => recipe.vegetarian);\r\n  } else if (filters.diet === 'vegan') {\r\n    filtered = filtered.filter(recipe => recipe.vegan);\r\n  } else if (filters.diet === 'gluten free') {\r\n    filtered = filtered.filter(recipe => recipe.glutenFree);\r\n  } else if (filters.diet === 'dairy free') {\r\n    filtered = filtered.filter(recipe => recipe.dairyFree);\r\n  }\r\n  \r\n  if (filters.maxReadyTime) {\r\n    filtered = filtered.filter(recipe => recipe.readyInMinutes <= filters.maxReadyTime);\r\n  }\r\n  \r\n  return filtered;\r\n};\r\n\r\n// Helper to create cache key from filters\r\nconst createCacheKey = (filters) => {\r\n  return JSON.stringify(filters);\r\n};\r\n\r\nexport const fetchRecipes = async (filters) => {\r\n  try {\r\n    const cacheKey = createCacheKey(filters);\r\n    \r\n    // Check cache first\r\n    if (apiCache.searches[cacheKey]) {\r\n      console.log(\"Using cached search results\");\r\n      return apiCache.searches[cacheKey];\r\n    }\r\n    \r\n    // If offline, use sample data\r\n    if (!isOnline()) {\r\n      console.log(\"Offline mode: Using sample data\");\r\n      return filterSampleRecipes(filters);\r\n    }\r\n    \r\n    const { query, cuisine, diet, intolerances, maxReadyTime, sort, offset, number = 10 } = filters;\r\n    \r\n    // Build API params\r\n    const params = {\r\n      query,\r\n      cuisine,\r\n      diet,\r\n      intolerances,\r\n      maxReadyTime,\r\n      sort,\r\n      offset,\r\n      number,\r\n      addRecipeInformation: true,\r\n      fillIngredients: true\r\n    };\r\n    \r\n    // Add additional filters if provided\r\n    if (filters.includeIngredients) params.includeIngredients = filters.includeIngredients;\r\n    if (filters.excludeIngredients) params.excludeIngredients = filters.excludeIngredients;\r\n    if (filters.type) params.type = filters.type;\r\n    if (filters.minCalories) params.minCalories = filters.minCalories;\r\n    if (filters.maxCalories) params.maxCalories = filters.maxCalories;\r\n    if (filters.minProtein) params.minProtein = filters.minProtein;\r\n    if (filters.maxProtein) params.maxProtein = filters.maxProtein;\r\n    if (filters.minCarbs) params.minCarbs = filters.minCarbs;\r\n    if (filters.maxCarbs) params.maxCarbs = filters.maxCarbs;\r\n    if (filters.minFat) params.minFat = filters.minFat;\r\n    if (filters.maxFat) params.maxFat = filters.maxFat;\r\n    \r\n    const url = buildApiUrl('complexSearch', params);\r\n    console.log(\"Fetching recipes from API:\", url);\r\n    \r\n    const response = await fetch(url);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(\"API request failed with status: \" + response.status);\r\n    }\r\n    \r\n    const data = await response.json();\r\n    const results = data.results || [];\r\n    \r\n    // Cache the results\r\n    apiCache.searches[cacheKey] = results;\r\n    \r\n    return results;\r\n  } catch (error) {\r\n    console.error(\"Error in fetchRecipes:\", error);\r\n    // Fallback to sample data\r\n    return filterSampleRecipes(filters);\r\n  }\r\n};\r\n\r\nexport const searchRecipes = fetchRecipes;\r\n\r\nexport const fetchRecipeById = async (recipeId) => {\r\n  try {\r\n    // Check cache first\r\n    if (apiCache.recipes[recipeId]) {\r\n      console.log(`Using cached recipe data for ID: ${recipeId}`);\r\n      return apiCache.recipes[recipeId];\r\n    }\r\n    \r\n    // If offline, use sample data\r\n    if (!isOnline()) {\r\n      console.log(\"Offline mode: Using sample data for recipe details\");\r\n      const recipe = sampleRecipes.find(r => r.id === parseInt(recipeId));\r\n      if (recipe) return recipe;\r\n      throw new Error(\"Recipe not found in sample data\");\r\n    }\r\n    \r\n    // Fetch from API\r\n    const params = {\r\n      includeNutrition: true\r\n    };\r\n    \r\n    const url = buildApiUrl(`${recipeId}/information`, params);\r\n    console.log(`Fetching recipe details for ID: ${recipeId}`);\r\n    \r\n    const response = await fetch(url);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(\"API request failed with status: \" + response.status);\r\n    }\r\n    \r\n    const recipe = await response.json();\r\n    \r\n    // Cache the recipe\r\n    apiCache.recipes[recipeId] = recipe;\r\n    \r\n    return recipe;\r\n  } catch (error) {\r\n    console.error(`Error fetching recipe ${recipeId}:`, error);\r\n    \r\n    // Try to find in sample data as fallback\r\n    const recipe = sampleRecipes.find(r => r.id === parseInt(recipeId));\r\n    \r\n    if (recipe) {\r\n      return recipe;\r\n    }\r\n    \r\n    throw error;\r\n  }\r\n};\r\n\r\nexport const getRecipeById = fetchRecipeById;\r\n\r\nexport const getSimilarRecipes = async (recipeId) => {\r\n  try {\r\n    // If offline, use sample data\r\n    if (!isOnline()) {\r\n      console.log(\"Offline mode: Using sample data for similar recipes\");\r\n      const shuffled = [...sampleRecipes].sort(() => 0.5 - Math.random());\r\n      return shuffled.slice(0, 4);\r\n    }\r\n    \r\n    const url = buildApiUrl(`${recipeId}/similar`, { number: 4 });\r\n    console.log(`Fetching similar recipes for ID: ${recipeId}`);\r\n    \r\n    const response = await fetch(url);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(\"API request failed with status: \" + response.status);\r\n    }\r\n    \r\n    const similarRecipes = await response.json();\r\n    \r\n    // Fetch full details for each similar recipe\r\n    const detailedRecipes = await Promise.all(\r\n      similarRecipes.map(async (recipe) => {\r\n        try {\r\n          return await fetchRecipeById(recipe.id);\r\n        } catch (error) {\r\n          console.error(`Error fetching details for similar recipe ${recipe.id}:`, error);\r\n          return recipe; // Return basic info if details fetch fails\r\n        }\r\n      })\r\n    );\r\n    \r\n    return detailedRecipes;\r\n  } catch (error) {\r\n    console.error(\"Error in getSimilarRecipes:\", error);\r\n    // Fallback to sample data\r\n    const shuffled = [...sampleRecipes].sort(() => 0.5 - Math.random());\r\n    return shuffled.slice(0, 4);\r\n  }\r\n};\r\n\r\nexport const getRecommendations = async (userProfile) => {\r\n  try {\r\n    // Create a unique cache key based on user profile\r\n    const cacheKey = userProfile ? JSON.stringify(userProfile) : 'default';\r\n    \r\n    // Check cache first\r\n    if (apiCache.recommendations[cacheKey]) {\r\n      console.log(\"Using cached recommendations\");\r\n      return apiCache.recommendations[cacheKey];\r\n    }\r\n    \r\n    // If offline, use sample data\r\n    if (!isOnline()) {\r\n      console.log(\"Offline mode: Using sample data for recommendations\");\r\n      return filterSampleRecipes({});\r\n    }\r\n    \r\n    // Default parameters if user profile is not available\r\n    let diet = '';\r\n    let intolerances = [];\r\n    let query = '';\r\n    let maxCalories = null;\r\n    let minProtein = null;\r\n    \r\n    // If user profile exists, use it to customize recommendations\r\n    if (userProfile) {\r\n      if (userProfile.goal === 'Weight Loss') {\r\n        diet = 'low-calorie';\r\n        maxCalories = Math.round(userProfile.tdee * 0.8); // 20% deficit\r\n      } else if (userProfile.goal === 'Build Muscle') {\r\n        diet = 'high-protein';\r\n        minProtein = 25; // Minimum 25g protein per serving\r\n      } else if (userProfile.goal === 'Maintain Weight') {\r\n        // Use TDEE as calories target\r\n      }\r\n      \r\n      intolerances = userProfile.allergies || [];\r\n    }\r\n    \r\n    // Create filters object for fetching recipes\r\n    const filters = {\r\n      query,\r\n      diet,\r\n      intolerances: intolerances.join(','),\r\n      sort: 'popularity',\r\n      maxReadyTime: 60,\r\n      number: 10,\r\n      maxCalories,\r\n      minProtein,\r\n      addRecipeInformation: true\r\n    };\r\n    \r\n    const results = await fetchRecipes(filters);\r\n    \r\n    // Cache the recommendations\r\n    apiCache.recommendations[cacheKey] = results;\r\n    \r\n    return results;\r\n  } catch (error) {\r\n    console.error('Error getting recommendations:', error);\r\n    return filterSampleRecipes({});\r\n  }\r\n};\r\n\r\nexport const saveRecipe = async (userId, recipe) => {\r\n  try {\r\n    const userRef = doc(db, 'users', userId);\r\n    const userDoc = await getDoc(userRef);\r\n    \r\n    if (!userDoc.exists()) {\r\n      // Create user document if it doesn't exist\r\n      await setDoc(userRef, {\r\n        savedRecipes: [recipe]\r\n      });\r\n    } else {\r\n      // Add recipe to existing savedRecipes array\r\n      await updateDoc(userRef, {\r\n        savedRecipes: arrayUnion(recipe)\r\n      });\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error saving recipe:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nexport const removeRecipe = async (userId, recipeId) => {\r\n  try {\r\n    const userRef = doc(db, 'users', userId);\r\n    const userDoc = await getDoc(userRef);\r\n    \r\n    if (userDoc.exists()) {\r\n      const savedRecipes = userDoc.data().savedRecipes || [];\r\n      const recipeToRemove = savedRecipes.find(recipe => recipe.id === recipeId);\r\n      \r\n      if (recipeToRemove) {\r\n        await updateDoc(userRef, {\r\n          savedRecipes: arrayRemove(recipeToRemove)\r\n        });\r\n      }\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('Error removing recipe:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nexport const getSavedRecipes = async (userId) => {\r\n  try {\r\n    const userRef = doc(db, 'users', userId);\r\n    const userDoc = await getDoc(userRef);\r\n    \r\n    if (userDoc.exists()) {\r\n      return userDoc.data().savedRecipes || [];\r\n    }\r\n    \r\n    return [];\r\n  } catch (error) {\r\n    console.error('Error getting saved recipes:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n// Clear cache\r\nexport const clearCache = () => {\r\n  apiCache.searches = {};\r\n  apiCache.recipes = {};\r\n  apiCache.recommendations = {};\r\n  console.log(\"API cache cleared\");\r\n};\r\n\r\n// New function to check if a recipe is saved by user\r\nexport const isRecipeSaved = async (userId, recipeId) => {\r\n  try {\r\n    if (!userId) return false;\r\n    \r\n    const savedRecipes = await getSavedRecipes(userId);\r\n    return savedRecipes.some(recipe => recipe.id === parseInt(recipeId));\r\n  } catch (error) {\r\n    console.error('Error checking if recipe is saved:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n// New function for advanced recipe search\r\nexport const advancedRecipeSearch = async (filters) => {\r\n  return fetchRecipes({\r\n    ...filters,\r\n    addRecipeInformation: true,\r\n    fillIngredients: true\r\n  });\r\n};\r\n\r\n// New function to search by ingredients\r\nexport const searchByIngredients = async (ingredients, number = 10) => {\r\n  try {\r\n    if (!isOnline()) {\r\n      console.log(\"Offline mode: Using sample data for ingredients search\");\r\n      return filterSampleRecipes({});\r\n    }\r\n    \r\n    const params = {\r\n      ingredients: ingredients.join(','),\r\n      number,\r\n      ranking: 1, // Maximize used ingredients\r\n      ignorePantry: true\r\n    };\r\n    \r\n    const url = buildApiUrl('findByIngredients', params);\r\n    console.log(\"Searching recipes by ingredients:\", url);\r\n    \r\n    const response = await fetch(url);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error(\"API request failed with status: \" + response.status);\r\n    }\r\n    \r\n    const results = await response.json();\r\n    \r\n    // Get full recipe details for each result\r\n    const detailedRecipes = await Promise.all(\r\n      results.map(async (recipe) => {\r\n        try {\r\n          return await fetchRecipeById(recipe.id);\r\n        } catch (error) {\r\n          console.error(`Error fetching details for recipe ${recipe.id}:`, error);\r\n          return recipe; // Return basic info if details fetch fails\r\n        }\r\n      })\r\n    );\r\n    \r\n    return detailedRecipes;\r\n  } catch (error) {\r\n    console.error(\"Error in searchByIngredients:\", error);\r\n    return filterSampleRecipes({});\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}